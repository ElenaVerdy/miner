function playingInit(io){

    const minesOnTheField = [];
    const fieldInfo = [];   
    
    io.on("connection", socketHandler);

    function socketHandler(socket){
        
        socket.on("disconnect", (data)=>{players.splice(players.indexOf(socket.id), 1)})

        socket.on("gameStart", (data)=>{
            
            width = data.fieldSizeOptions.width;
            height = data.fieldSizeOptions.height;
            num = data.fieldSizeOptions.num;

            minesOnTheField.length = 0;

            for (let i = 0; i < width * height; i++) {
                minesOnTheField.push(0);
            }

            for (let i = 0; i < num; i++) {
                let newMinePlace = (Math.random() * width * height) ^ 0;

                if (minesOnTheField[newMinePlace] === true || newMinePlace === data.cellId) {
                    i--;
                    continue;
                }
                minesOnTheField[newMinePlace] = true;
            }

            for (var i = 0; i < minesOnTheField.length; i++) {
                fieldInfo.push({
                    "cell": true,
                    "cell-closed": true
                });

                if (minesOnTheField[i] !== true) continue;

                let x = i % width,
                    y = (i / width)^0;

                for (let k = y > 0 ? y - 1 : y; k <= y + 1 && k < height; k++) {
                    for (var j = x > 0 ? x - 1 : x; j <= x + 1 && j < width; j++) {
                        
                        if (k * width + j === i || minesOnTheField[k * width + j] === true) continue;

                        minesOnTheField[k * width + j]++;
                    }
                }

            
            };

            let fieldUpdate = openTheCell(data.cellId);

            io.sockets.emit("gameStarted", {
                cellId: data.cellId, fieldUpdate: fieldUpdate, fieldSize: data.fieldSize
            });

        });

        socket.on("cell-opened", data => {
            let fieldUpdate = {};
            if (minesOnTheField[data.cellId] === true) {
                
                fieldInfo.length = 0;
                minesOnTheField.forEach((cell, i) => {
                    if (cell !== true) return;

                    fieldUpdate[i] = {exploded: true}
                });

                io.sockets.emit("gameOver", {
                    wrong: data.cellId,
                    fieldUpdate: fieldUpdate
                });

            } else {
                fieldUpdate = openTheCell(data.cellId);

                io.sockets.emit("fieldUpdated", {fieldUpdate: fieldUpdate, fieldInfo: fieldInfo})

                if (checkForTheWin()) io.sockets.emit("won");
            }
        })

        socket.on("flag", data => {
            let fieldUpdate = {[Object.keys(data)[0]]: {flag: data[Object.keys(data)[0]]}};
            fieldInfo[Object.keys(data)[0]].flag = data[Object.keys(data)[0]];
            io.sockets.emit("fieldUpdated", {fieldUpdate: fieldUpdate});
        })
        
    }

    function openTheCell(targetNum){
        let fieldUpdate = {};
        let queue = [targetNum];
        let visited = [];

        while (queue.length) {

            let next = queue.pop();
            visited.push(next);

            fieldUpdate[next] = {};
            fieldInfo[next]["cell-opened"] = fieldUpdate[next]["cell-opened"] = true;
            fieldInfo[next]["cell-closed"] = fieldUpdate[next]["cell-closed"] = false;
            fieldInfo[next]["flag"] = fieldUpdate[next]["flag"] = false;

            if (minesOnTheField[next]) {
                fieldInfo[next].num = fieldUpdate[next].num = minesOnTheField[next];
                continue;
            }

            let x = next % width,
            y = (next / width)^0;

            for (let k = y > 0 ? y - 1 : y; k <= y + 1 && k < height; k++) {
                for (var j = x > 0 ? x - 1 : x; j <= x + 1 && j < width; j++) {
                    
                    if (k * width + j === next) continue;

                    if (!(~visited.indexOf(k * width + j))) queue.push(k * width + j);
                }
            }

        }
        return fieldUpdate;
    }

    function checkForTheWin(){

        let cellClosed = flag = num = 0;
        
        fieldInfo.forEach((item, i) => {
            if (item["cell-closed"]) cellClosed++;
            if (minesOnTheField[i] === true) num++;
        })
        
        if (cellClosed === num) return true;
        
        return false;
    }

}

module.exports.run = playingInit;