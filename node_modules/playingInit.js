function playingInit(io, pool){
    const width = 50,
          height = 16,
          num = 120;
    var tables = [];

    this.createNewTable = createNewTable;
    this.getTables = getTables;
    this.joinGame = joinGame;
    this.getGame = getGame;


    function getTables(){ return tables.sort((a, b)=> {return a.tableNum - b.tableNum}) };
    
    io.on("connection", connectionHandler);

    function tableNum () {
        tables = getTables();
        let k = tables.length;
        if (k == 0 || tables[0].tableNum !== 0) return 0;

        for (var i = 1; i < k; i++) {
            if (tables[i].tableNum === i + 1) continue;

            return i + 1;
        }
    }
    function createNewTable (user) {
        let newTable = {
            startTime: null,
            finishTime: null,
            isGameOn: false,
            tableNum: tableNum(),
            gameId: (Math.random()*100000000 ^ 0),
            player1: user,
            player2: null,
            minesOnTheField: [],
            fieldInfo: []
        }

        newTable.player1.isInGame = true;
        newTable.player1.touches = 0;
        tables.push(newTable);

        return newTable;
    }
    function joinGame(user, gameId) {
        let k = -1;
        for (var i = 0; i < tables.length; i++) {
            if (tables[i].gameId == gameId) {
                k = i;
                break;
            }
        }
        if (k == -1) return;
        
        if (!tables[k].player2) {
            tables[k].player2 = user;
            tables[k].player2.isInGame = true;
            tables[k].player2.touches = 0;

            return tables[k];
        }

        if (tables[k].player1.username !== user.username && tables[k].player2.username !== user.username) return;
        
        else return tables[k];
    }
    function getGame(gameId) {
        for (var i = 0; i < tables.length; i++) {
            if (tables[i].gameId == gameId) return tables[i];
        };
    }
    function gameOver(gameId) {
        let k = -1;
        for (var i = 0; i < tables.length; i++) {
            if (tables[i].gameId == gameId) {
                k = i;
                break;
            }
        }
        if (k == -1) return;

        tables.splice(k, 1);
        return gameId;
    }
    function connectionHandler(socket){
        
        socket.on("disconnecting", (data) => {
            let rooms = Object.keys(socket.rooms);

            if (rooms.length < 2) return;

            rooms.forEach( room =>{
                
                if (room.slice(0, 4) !== "Game") return;

                let game = getGame(room.slice(4));
                if (!game) return;

                if (!game.isGameOn) {

                    if (game.player1.username === socket.username && game.player2 && game.player2.isInGame) {
                        game.player1 = game.player2;
                        game.player2 = null;
                        io.sockets.in(`Game${game.gameId}`).emit("playerLeftBeforeTheGameStarted", game);
                    } else if (game.player2 && (game.player2.username === socket.username)) {
                        game.player2 = null;
                        io.sockets.in(`Game${game.gameId}`).emit("playerLeftBeforeTheGameStarted", game)
                    }

                } else {
                    
                    if (game.player1.username === socket.username) {
                        game.player1.isInGame = false;
                    } else if (game.player2 && (game.player2.username === socket.username)) {
                        game.player2.isInGame = false;
                    }

                }

                if (!game.player1.isInGame && (!game.player2 || !game.player2.isInGame)) gameOver(game.gameId);
                
            })
        });
        
        socket.on("getFieldInfo", data => {
            socket.emit("fieldUpdated", {fieldUpdate: getGame(data.gameId).fieldInfo});            
        })

        socket.on("join", (data) => {

            if (Object.keys(socket.rooms).length > 1) console.log("Thats some large todo")
            socket.join(`Game${data.gameId}`);
            socket.username = data.username;

            io.of('/').in(`Game${data.gameId}`).clients(function(error,clients){
               
                if (clients.length == 2) {
                    let {player1, player2} = getGame(data.gameId);
                    io.in(`Game${data.gameId}`).emit("ready", {player1, player2});
                    player2.isInGame = true;
                };
            });
            
        });

        socket.on("gameStart", (data)=>{
            let game = getGame(data.gameId);
            game.isGameOn = true;
            game.startTime = new Date().valueOf();
            const {minesOnTheField, fieldInfo} = game; 
            
            minesOnTheField.length = 0;

            for (let i = 0; i < width * height; i++) {
                minesOnTheField.push(0);
            }

            for (let i = 0; i < num; i++) {
                let newMinePlace = (Math.random() * width * height) ^ 0;

                if (minesOnTheField[newMinePlace] === true || newMinePlace === data.cellId) {
                    i--;
                    continue;
                }
                minesOnTheField[newMinePlace] = true;
            }

            for (var i = 0; i < minesOnTheField.length; i++) {
                fieldInfo.push({
                    "cell": true,
                    "cell-closed": true
                });

                if (minesOnTheField[i] !== true) continue;

                let x = i % width,
                    y = (i / width)^0;

                for (let k = y > 0 ? y - 1 : y; k <= y + 1 && k < height; k++) {
                    for (var j = x > 0 ? x - 1 : x; j <= x + 1 && j < width; j++) {
                        
                        if (k * width + j === i || minesOnTheField[k * width + j] === true) continue;

                        minesOnTheField[k * width + j]++;
                    }
                }

            
            };

            let fieldUpdate = openTheCell(data.cellId, minesOnTheField, fieldInfo);

            io.sockets.in(`Game${data.gameId}`).emit("fieldUpdated", {
                cellId: data.cellId, 
                fieldUpdate: fieldUpdate,
                firstMove: true
            });

        });

        socket.on("cell-opened", data => {
            const game = getGame(data.gameId);
            const {minesOnTheField, fieldInfo, player1, player2} = game; 

            let fieldUpdate = {};
            if (minesOnTheField[data.cellId] === true) {
                
                fieldInfo.length = 0;
                minesOnTheField.forEach((cell, i) => {
                    if (cell !== true) return;

                    fieldUpdate[i] = {exploded: true}
                });

                game.isGameOn = false;
                io.sockets.in(`Game${data.gameId}`).emit("gameOver", {
                    wrong: data.cellId,
                    fieldUpdate: fieldUpdate
                });

            } else {
                fieldUpdate = openTheCell(data.cellId, minesOnTheField, fieldInfo);
                
                if (socket.username === player1.username) {
                    player1.touches = ++player1.touches;
                } else {
                    player2.touches = ++player2.touches;
                }

                io.sockets.in(`Game${data.gameId}`).emit("fieldUpdated", {
                                                                            fieldUpdate, 
                                                                            player1touches: player1.touches, 
                                                                            player2touches: player2.touches 
                                                                         });

                if (checkForTheWin(fieldInfo, minesOnTheField)) gameWon(data.gameId);
            }
        })

        socket.on("flag", data => {
            const cellId = Object.keys(data)[0];
            const {player1, fieldInfo} = getGame(data.gameId);

            let fieldUpdate = {[cellId]: {flag: data[cellId] ? (socket.username === player1.username ? "flag1" : "flag2") : false }};
            fieldInfo[Object.keys(data)[0]].flag = fieldUpdate[cellId].flag;
            io.sockets.in(`Game${data.gameId}`).emit("fieldUpdated", {fieldUpdate: fieldUpdate});
        })
        
    }

    function openTheCell(targetNum, minesOnTheField, fieldInfo){
        let fieldUpdate = {};
        let queue = [targetNum];
        let visited = [];

        while (queue.length) {

            let next = queue.pop();
            visited.push(next);

            fieldUpdate[next] = {};
            fieldInfo[next]["cell-opened"] = fieldUpdate[next]["cell-opened"] = true;
            fieldInfo[next]["cell-closed"] = fieldUpdate[next]["cell-closed"] = false;
            fieldInfo[next]["flag"] = fieldUpdate[next]["flag"] = false;

            if (minesOnTheField[next]) {
                fieldInfo[next].num = fieldUpdate[next].num = minesOnTheField[next];
                continue;
            }

            let x = next % width,
            y = (next / width)^0;

            for (let k = y > 0 ? y - 1 : y; k <= y + 1 && k < height; k++) {
                for (var j = x > 0 ? x - 1 : x; j <= x + 1 && j < width; j++) {
                    
                    if (k * width + j === next) continue;

                    if (!(~visited.indexOf(k * width + j))) queue.push(k * width + j);
                }
            }

        }
        return fieldUpdate;
    }

    function checkForTheWin(fieldInfo, minesOnTheField){
        let num;
        let cellClosed = flag = num = 0;
        
        fieldInfo.forEach((item, i) => {
            if (item["cell-closed"]) cellClosed++;
            if (minesOnTheField[i] === true) num++;
        })
        
        if (cellClosed === num) return true;
        
        return false;
    }

    function gameWon(gameId) {
        let game = getGame(gameId);

        game.isGameOn = false;
        game.finishTime = new Date().valueOf();

        pool.connect((err, client, release) => {

            let query = `INSERT INTO recordstwoplayers (gameid, player1username, player2username, timems) 
                                                values (${game.gameId}, '${game.player1.username}', '${game.player2.username}', ${game.finishTime - game.startTime})`;
            if (err) {
                console.log("inserting new record in multiplayer: ", err);
                io.sockets.in(`Game${gameId}`).emit("error");
            }
            client.query(query, (err, result) => {

                release()

                if (err) {
                    console.log(err);
                    io.sockets.in(`Game${gameId}`).emit("error");
                }
                
                pool.connect((err, client, release) => {
                    let query = `SELECT * FROM recordstwoplayers ORDER BY timems ASC`;
                    if (err) {
                        console.log(err)
                        io.sockets.in(`Game${gameId}`).emit("error");
                    }
                    client.query(query, (err, result) => {
        
                        release();
        
                        if (err) {
                            console.log("selecting top records from mupltiplayer: ", err);
                            io.sockets.in(`Game${gameId}`).emit("error");
                            return;
                        }

                        let currentGame, k = -1;
                        result.rows.forEach((item, i) => {
                            if (item.gameid == gameId) k = i;
                        })

                        if (k === -1) {
                            io.sockets.in(`Game${gameId}`).emit("error");
                        } else {
                            currentGame = result.rows[k];
                            currentGame.num = k;
                            currentGame.isCurrentGame = true;
                        }
                        result.rows.splice(10);
                        if (k >= 10) result.rows.push(currentGame);
                        
                        io.sockets.in(`Game${gameId}`).emit("resultsReady", {result: result.rows});                        
        
                    })
                })
                

            })
        })

        
    }
}

module.exports.run = playingInit;