function playingInit(io, pool, teamplayGameField){
    const {width, height, num} = teamplayGameField;
    var tables = [];
    const PTSforWIN = 500;
    const PTSforLOSS = 40;

    // setInterval(function(){
    //     tables.forEach(item => {
    //         console.log(`gameOver: ${item.gameOver}, isGameOn: ${item.isGameOn}, tableNum: ${item.tableNum}, player1: ${item.player1.isInGame}, player2: ${item.player2 ? item.player2.isInGame : false}`);
    //     })
    // }, 5000)
    this.createNewTable = createNewTable;
    this.getTablesForUser = getTablesForUser;
    this.joinGame = joinGame;
    this.getGame = getGame;
    
    io.on("connection", connectionHandler);

    function getTables(){ return tables.sort((a, b)=> {return a.tableNum - b.tableNum}) };

    function getTablesForUser(username){

        return tables.filter( item => {

            return !item.gameOver && !item.finishTime &&                  // game is not lost or won
                   ((!item.player2 && !item.isPrivate) ||                 // there is no second player in non-private game
                   (item.player2 && item.player2.username === username) ||// requester is player2
                   (item.player1.username === username));                 // requester is player1

        })
        .sort((a, b)=> {return a.tableNum - b.tableNum});
    
    }
    function tableNum () {
        tables = getTables();

        let k = tables.length;
        if (k == 0 || tables[0].tableNum !== 1) return 1;

        for (var i = 0; i < k; i++) {
            if (tables[i].tableNum === i + 1) continue;

            return i + 1;
        }
        return k + 1;
    }
    function createNewTable (user, isPrivate) {
        let newTable = {
            startTime: null,
            finishTime: null,
            gameOver: false,
            isGameOn: false,
            tableNum: tableNum(),
            gameId: (Math.random()*100000000 ^ 0),
            player1: user,
            player2: null,
            isPrivate: isPrivate,
            minesOnTheField: [],
            fieldInfo: []
        }

        newTable.player1.isInGame = true;
        newTable.player1.touches = 0;
        tables.push(newTable);

        return newTable;
    }
    function joinGame(user, gameId) {
        let k = -1;
        for (var i = 0; i < tables.length; i++) {
            if (tables[i].gameId == gameId) {
                k = i;
                break;
            }
        }
        if (k == -1) 
            return "The game wasn't found. It probably ended, please refresh the page.";
        
        if (!tables[k].player2) {

            if (tables[k].player1.username === user.username)
                return "You can not be your own teammate!";

            tables[k].player2 = user;
            tables[k].player2.isInGame = true;
            tables[k].player2.touches = 0;

            return tables[k];
        }

        if (tables[k].player1.username !== user.username && tables[k].player2.username !== user.username) 
            return "You are not allowed to join this game!";

        if (tables[k].player1.username === user.username) tables[k].player1.isInGame = true;
        if (tables[k].player2.username === user.username) tables[k].player2.isInGame = true;
        
        return tables[k];
    }
    
    function getGame(gameId) {
        for (var i = 0; i < tables.length; i++) {
            if (tables[i].gameId == gameId) return tables[i];
        };
    }
    function gameOver(gameId) {
        let k = -1;
        for (var i = 0; i < tables.length; i++) {
            if (tables[i].gameId == gameId) {
                k = i;
                break;
            }
        }
        if (k == -1) return;

        if (tables[k].isGameOn) {
            updateRating(tables[k]);
        }

        tables.splice(k, 1);
        return gameId;
    }
    function playerDisconnected(game, username) {
            // console.log(`gameOver: ${game.gameOver}, isGameOn: ${game.isGameOn}, tableNum: ${game.tableNum}, player1: ${game.player1.isInGame}, player2: ${game.player2 ? game.player2.isInGame : false}`);

            if (!game.isGameOn && !game.gameOver) {

            if (game.player1.username === username && game.player2 && game.player2.isInGame) {
                game.player1 = game.player2;
                game.player2 = null;
                io.sockets.in(`Game${game.gameId}`).emit("playerLeftBeforeTheGameStarted", game);
            } else if (game.player2 && (game.player2.username === username)) {
                game.player2 = null;
                io.sockets.in(`Game${game.gameId}`).emit("playerLeftBeforeTheGameStarted", game)
            } else if (!game.player2 && game.player1.username === username) game.player1.isInGame = false;

        } else {
            
            if (game.player1.username === username) {
                game.player1.isInGame = false;
            } else if (game.player2 && (game.player2.username === username)) {
                game.player2.isInGame = false;
            }

            io.sockets.in(`Game${game.gameId}`).emit("playersInfoUpdated", {player1: game.player1, player2: game.player2});

        }

        if (!game.player1.isInGame && (!game.player2 || !game.player2.isInGame)) gameOver(game.gameId);

    }
    function connectionHandler(socket){
        socket.on("disconnecting", (data) => {
            let rooms = Object.keys(socket.rooms);

            if (rooms.length < 2) return;

            rooms.forEach( room =>{
                
                if (room.slice(0, 4) !== "Game") return;

                let game = getGame(room.slice(4));
                if (!game) return;
                playerDisconnected(game, socket.username)
            })
        });
        
        socket.on("getFieldInfo", data => {
            let game = getGame(data.gameId);
            if (!game) return socket.emit("myError", {status: 404, text: "getFieldInfo: game not found"});

            socket.emit("fieldUpdated", {fieldUpdate: game.fieldInfo, gameStart: game.startTime});            
        });
        
        socket.on("join", (data) => {

            let game = getGame(data.gameId);
            if (!game) return socket.emit("myError", {status: 404, text: "join: game not found"});

            if (Object.keys(socket.rooms).length > 1) {
                let rooms = Object.keys(socket.rooms);
                rooms.forEach(room => {
                    if (room.slice(0, 4) !== "Game") return;
                    socket.leave(room);
                    let game = getGame(room.slice(4));
                    if (game)
                        playerDisconnected(game, socket.username);
                });
            }

            socket.join(`Game${data.gameId}`);

            socket.username = data.username;

            //io.of('/').in(`Game${data.gameId}`).clients(function(error,clients){
            //if (!error) return socket.emit("myError", {status: 500, text: "Couldnt count sockets in room lol"});

    		let clients = io.sockets.adapter.rooms[`Game${data.gameId}`];

            if (clients.length == 2 && !game.isGameOn) {
                
                let {player1, player2} = game;
                io.in(`Game${data.gameId}`).emit("ready", {player1, player2, startTime: Date.now() + 5000});

            } else if (clients.length == 2) {

                let {player1, player2} = game;                    
                io.in(`Game${data.gameId}`).emit("playersInfoUpdated", {player1, player2});
            
            }

            //});
        });

        socket.on("gameStart", (data)=>{
            let game = getGame(data.gameId);
            if (!game) return socket.emit("myError", {status: 404});

            if (!game.player1 || !game.player2)
                return io.sockets.in(`Game${game.gameId}`).emit("myError", {status: 500, text: "gameStart: teammate left"});

            if (game.isGameOn) return;
            game.isGameOn = true;

            game.startTime = Date.now();
            const {minesOnTheField, fieldInfo} = game; 
            
            minesOnTheField.length = 0;

            for (let i = 0; i < width * height; i++) {
                minesOnTheField.push(0);
            }

            for (let i = 0; i < num; i++) {
                let newMinePlace = (Math.random() * width * height) ^ 0;

                if (minesOnTheField[newMinePlace] === true || newMinePlace === data.cellId) {
                    i--;
                    continue;
                }
                minesOnTheField[newMinePlace] = true;
            }

            for (var i = 0; i < minesOnTheField.length; i++) {
                fieldInfo.push({
                    "cell": true,
                    "cell-closed": true
                });

                if (minesOnTheField[i] !== true) continue;

                let x = i % width,
                    y = (i / width)^0;

                for (let k = y > 0 ? y - 1 : y; k <= y + 1 && k < height; k++) {
                    for (var j = x > 0 ? x - 1 : x; j <= x + 1 && j < width; j++) {
                        
                        if (k * width + j === i || minesOnTheField[k * width + j] === true) continue;

                        minesOnTheField[k * width + j]++;
                    }
                }

            
            };

            let fieldUpdate = openTheCell(data.cellId, minesOnTheField, fieldInfo);

            io.sockets.in(`Game${data.gameId}`).emit("fieldUpdated", {
                cellId: data.cellId, 
                fieldUpdate: fieldUpdate,
                gameStart: game.startTime
            });

        });

        socket.on("cell-opened", data => {
            const game = getGame(data.gameId);
            if (!game) return socket.emit("myError", {status: 404, text: "cell-opened: game not found"});

            const {minesOnTheField, fieldInfo, player1, player2} = game; 

            let fieldUpdate = {};
            if (minesOnTheField[data.cellId] === true) {
                
                minesOnTheField.forEach((cell, i) => {
                    if (cell !== true) return;

                    fieldUpdate[i] = {exploded: true}
                });

                game.isGameOn = false;
                game.loserUsername = socket.username;
                game.gameOver = true;
                io.sockets.in(`Game${data.gameId}`).emit("gameOver", {
                    wrong: data.cellId,
                    fieldUpdate: fieldUpdate
                });
                
                //send best results
                pool.connect((err, client, release) => {
                    let query = `SELECT * FROM recordstwoplayers ORDER BY timems ASC`;
                    if (err) {
                        console.log(err)
                        io.sockets.in(`Game${game.gameId}`).emit("myError", {status: 500, text: "cant connect to pool to select recordstwoplayers"});
                    }
                    client.query(query, (err, result) => {
        
                        release();
        
                        if (err) {
                            console.log("selecting top records from mupltiplayer: ", err);
                            io.sockets.in(`Game${game.gameId}`).emit("myError", {status: 500, text: "cant select recordstwoplayers"});
                            return;
                        }

                        result.rows.splice(10);
                        
                        io.sockets.in(`Game${game.gameId}`).emit("resultsReady", {result: result.rows, text: "GAME OVER"});                        
                        
                    })
                })
                
                updateRating(game);

                fieldInfo.length = 0;
            } else {
                fieldUpdate = openTheCell(data.cellId, minesOnTheField, fieldInfo);
                
                if (socket.username === player1.username) {
                    player1.touches = ++player1.touches;
                } else {
                    player2.touches = ++player2.touches;
                }

                io.sockets.in(`Game${data.gameId}`).emit("fieldUpdated", {
                                                                            fieldUpdate, 
                                                                            player1touches: player1.touches, 
                                                                            player2touches: player2.touches 
                                                                         });

                if (checkForTheWin(fieldInfo, minesOnTheField)) gameWon(data.gameId);
            }
        });

        socket.on("flag", data => {
            let game = getGame(data.gameId);
            if (!game) return socket.emit("myError", {status: 404, text: "flag: game not found"});

            const cellId = Object.keys(data)[0];
            const {player1, fieldInfo} = game;

            let fieldUpdate = {[cellId]: {flag: data[cellId] ? (socket.username === player1.username ? "flag1" : "flag2") : false }};
            fieldInfo[Object.keys(data)[0]].flag = fieldUpdate[cellId].flag;
            io.sockets.in(`Game${data.gameId}`).emit("fieldUpdated", {fieldUpdate: fieldUpdate});
        });

        socket.on("playAgain", data => {
            let game = getGame(data.gameId_old);

            if (game) {

                if (game.playAgainSuggested) return;

                game.playAgainSuggested = true;
                
                io.of('/').in(`Game${game.gameId}`).clients(function(error, clients){

                    if (error) return socket.emit("myError", {status: 500, text: "play again"});
                    if (clients.length !== 2) return socket.emit("myError", {status: 444, text: "Your teammate already left."});
                    
                    disconnected = [false, false];

                    clients.forEach((item, i) => {
                        
                        io.of("/").connected[item].on("disconnect", () =>{
                            if (!disconnected[i]) {
                                io.sockets.in(clients[i ? 0 : 1]).emit("replayDeclined");                
                            }
        
                            disconnected[i] = true;
                        });
                    });
                    
                });

                io.sockets.in(`Game${data.gameId_old}`).emit("playAgainSuggestion", {
                                                                                        gameId: data.gameId,
                                                                                        initiator: socket.id,
                                                                                        initiatorUsername: socket.username,
                                                                                        sendTime: Date.now()
                                                                                    });
                if (!game.player1.isInGame && !game.player2.isInGame) {
                    io.sockets.in(socker.id).emit("replayDeclined")
                }
            }
        })
        
    }

    function openTheCell(targetNum, minesOnTheField, fieldInfo){
        let fieldUpdate = {};
        let queue = [targetNum];
        let visited = [];

        while (queue.length) {

            let next = queue.pop();
            visited.push(next);

            if (fieldInfo[next] === undefined)
                return io.sockets.in(`Game${game.gameId}`).emit("myError", {status: 500, text: "Some weird error in OpenTheCell method ¯\\_(ツ)_/¯"});

            fieldUpdate[next] = {};
            fieldInfo[next]["cell-opened"] = fieldUpdate[next]["cell-opened"] = true;
            fieldInfo[next]["cell-closed"] = fieldUpdate[next]["cell-closed"] = false;
            fieldInfo[next]["flag"] = fieldUpdate[next]["flag"] = false;

            if (minesOnTheField[next]) {
                fieldInfo[next].num = fieldUpdate[next].num = minesOnTheField[next];
                continue;
            }

            let x = next % width,
            y = (next / width)^0;

            for (let k = y > 0 ? y - 1 : y; k <= y + 1 && k < height; k++) {
                for (var j = x > 0 ? x - 1 : x; j <= x + 1 && j < width; j++) {
                    
                    if (k * width + j === next) continue;

                    if (!(~visited.indexOf(k * width + j))) queue.push(k * width + j);
                }
            }

        }
        return fieldUpdate;
    }

    function checkForTheWin(fieldInfo, minesOnTheField){
        for (let i = 0; i < fieldInfo.length; i++) {
            if (fieldInfo[i]["cell-closed"] && minesOnTheField[i] !== true) return false;
        }
        return true;
    }

    function rankChange(game) {
        
        let player1ratio = game.player1.touches / (game.player1.touches + game.player2.touches);
        
        if (!(game.player1.touches + game.player2.touches)) {
            return {[game.player1.username]: -10, 
                    [game.player2.username]: -10};
        }

        let player1PTS, 
            player2PTS;

        if (game.finishTime) {
            player1PTS = Math.round(PTSforWIN * player1ratio);
            player2PTS = PTSforWIN - player1PTS;
        } else {
            let PTSforLOSSLoc = game.fieldInfo.filter(item => {
                return !item["cell-closed"]; 
            }).length / (width * height - num) * PTSforLOSS / 2;

            if (game.player1.username == game.loserUsername) {
            
                player1PTS = -25;
                player2PTS = Math.round(PTSforLOSSLoc * (1 - player1ratio)) - 20; 
            
            } else if (game.player2.username == game.loserUsername) {
            
                player1PTS = Math.round(PTSforLOSSLoc * player1ratio) - 20; 
                player2PTS = -25;
            
            } else if (!game.loserUsername) {

                player1PTS = Math.round(PTSforLOSSLoc * player1ratio) - 20; 
                player2PTS = Math.round(PTSforLOSSLoc * (1 - player1ratio)) - 20; 
            
            }
        }

        return {[game.player1.username]: player1PTS, 
                [game.player2.username]: player2PTS};
    }

    function updateRating(game) {
        let calcedRankChange = rankChange(game);

        let players = Object.keys(calcedRankChange);

        calcedRankChange.player1 = game.player1.isGuest ?  null : {
            username: game.player1.username,
            start: game.player1.rank,
            delta: calcedRankChange[players[0]],
            total: game.player1.rank + calcedRankChange[players[0]],
            touches: game.player1.touches
        };
        calcedRankChange.player2 = game.player2.isGuest ?  null : {
            username: game.player2.username,
            start: game.player2.rank,
            delta: calcedRankChange[players[1]],
            total: game.player2.rank + calcedRankChange[players[1]],
            touches: game.player2.touches
        }

        if (!calcedRankChange.player1 && !calcedRankChange.player2)
            return;

        if (calcedRankChange.player1 && !calcedRankChange.player2)
            [calcedRankChange.player1, calcedRankChange.player2] = [calcedRankChange.player2, calcedRankChange.player1];


        pool.connect((err, client, release) => {
            if (err) {
                console.log(err)
                return io.sockets.in(`Game${game.gameId}`).emit("myError", {status: 500});
            }

            client.query(`update users set
                                rank = new_data.rank
                                from (values
                                    ${calcedRankChange.player1 ? `('${calcedRankChange.player1.username}', ${calcedRankChange.player1.total}),` : ""}
                                    ('${calcedRankChange.player2.username}', ${calcedRankChange.player2.total})
                                ) as new_data(username, rank)
                            where new_data.username = users.username;`)
            .then(res => {
                io.sockets.in(`Game${game.gameId}`).emit("rankUpdated", calcedRankChange);
            })
            .catch(err => {
                console.log("cannot update records from users table", err);
                io.sockets.in(`Game${game.gameId}`).emit("myError", {status: 500});
            })

        })
             
    }

    function gameWon(gameId) {
        let game = getGame(gameId);

        game.isGameOn = false;
        game.finishTime = Date.now();

        updateRating(game);

        pool.connect((err, client, release) => {
            let timems = game.finishTime - game.startTime;
            let query = `INSERT INTO recordstwoplayers (player1username, player2username, timems) values ('${game.player1.isGuest ? 
                        "Guest" : game.player1.username}', '${game.player2.isGuest ? "Guest" : game.player2.username}', ${timems}) returning gameId`;
            if (err) {
                console.log("inserting new record in multiplayer: ", err);
                io.sockets.in(`Game${gameId}`).emit("myError", {status: 500});
            }
            client.query(query, (err, result) => {
                
                let dbGameId = result.rows[0].gameid;

                release();

                if (err) {
                    console.log(err);
                    io.sockets.in(`Game${gameId}`).emit("myError", {status: 500});
                }
            
                pool.connect((err, client, release) => {
                    let query = `SELECT * FROM recordstwoplayers ORDER BY timems ASC`;
                    if (err) {
                        console.log(err)
                        io.sockets.in(`Game${gameId}`).emit("myError", {status: 500});
                    }
                    client.query(query, (err, result) => {
        
                        release();
        
                        if (err) {
                            console.log("selecting top records from mupltiplayer: ", err);
                            io.sockets.in(`Game${gameId}`).emit("myError", {status: 500});
                            return;
                        }

                        let currentGame, k = -1;
                        result.rows.forEach((item, i) => {
                            if (item.gameid == dbGameId) k = i;
                        })

                        if (k === -1) {
                            io.sockets.in(`Game${gameId}`).emit("myError", {status: 500, text: "The game was not inserted into db!"});
                        } else {
                            currentGame = result.rows[k];
                            currentGame.num = k;
                            currentGame.isCurrentGame = true;
                        }
                        result.rows.splice(10);
                        if (k >= 10) result.rows.push(currentGame);
                        
                        io.sockets.in(`Game${gameId}`).emit("resultsReady", {result: result.rows, text: "CONGRATULATIONS!"});                        
        
                    })
                })
                

            })
        })

    }
}

module.exports.run = playingInit;
